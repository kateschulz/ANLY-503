# -*- coding: utf-8 -*-
"""Eigenfaces.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16k9bdABARucLhwR309u0ktv2WY9mQFaD
"""


import os 
from PIL import Image
import numpy as np
import pandas as pd 
from scipy.spatial import distance

def read_images(path):
    
    imagearray = []
    
    for dirname, dirnames, filenames in os.walk(path):
        for subdirname in dirnames:
            subject_path = os.path.join(dirname,subdirname)
            
            for filename in os.listdir(subject_path):
                im = Image.open(os.path.join(subject_path,filename))
                im = im.convert("L")
                imagearray.append(np.array(im).ravel())
                    
    return imagearray

path = 'FACESdata'
face_vectors = read_images(path)

face_matrix = np.matrix(face_vectors)
face_matrix_t = np.transpose(face_matrix)

original_shape = (112, 92)

#prove vectors can be returned to images
face_example = np.asarray(face_matrix_t[:,0]).reshape(original_shape)
face_example_img = Image.fromarray(face_example, 'L') 
face_example_img.show()
face_example_img.save("FaceExampleOutput.jpg")

#compute mean face and create image
mean_face = np.asarray(np.int8((np.mean(face_matrix_t, axis = 1))))
flat_mean_face = mean_face.ravel()
mean_face_img = Image.fromarray(flat_mean_face.reshape(original_shape), 'L') 
mean_face_img.show() 
mean_face_img.save("meanface.jpg")

#normalize face matrix
face_matrix_norm = face_matrix_t - mean_face

#compute eigenvalues and eigenvectors
face_matrix_norm_t = np.transpose(face_matrix_norm) 
cov_matrix = np.matmul(face_matrix_norm_t, face_matrix_norm) 
evals,evects = np.linalg.eig(cov_matrix)

#error trapping for user input
try:
    input = raw_input
except NameError:
    pass

def prompt(message, errormessage, isvalid):
    res = None
    while res is None:
        res = input(str(message)+': ')
        if not isvalid(res):
            print (str(errormessage))
            res = None
    return res

#user input number of eigenvalues to use
num_evals = prompt(
        message = 'How many eigenvalues? ', 
        errormessage = 'Number of eigenvalues must be less than 400',
        isvalid = lambda num : int(num) <= 400)

#sort for largest eigenvalues based on user input
idx = evals.argsort()[-int(num_evals):][::-1] 
evals_sort = evals[idx]
evects_sort = evects[:,idx]

eig_pairs = [(np.abs(evals_sort[i]), evects_sort[:,i]) for i in range(len(evals_sort))]

#create matrix of 5 eigenvalues

#missing 1, should be 400
eigen_matrix = np.hstack((eig_pairs[0][1].reshape(400,1), 
                      eig_pairs[1][1].reshape(400,1),
                      eig_pairs[2][1].reshape(400,1),
                      eig_pairs[3][1].reshape(400,1),
                      eig_pairs[4][1].reshape(400,1)))

#create eigenface matrix 
eigenface_matrix = face_matrix_norm.dot(eigen_matrix)

#write eigenvalues and eigenfaces to .CSVs
evals_df = pd.DataFrame(evals_sort)
evals_df.to_csv("top5_eigenvalues.csv", header=None)
evects_df = pd.DataFrame(eigenface_matrix)
evects_df.to_csv("top5_eigenfaces.csv", header=None)

#create .JPGs for 5 principal eigenfaces
eigen_face_1 = np.asarray(np.int8(eigenface_matrix[:,0]).reshape(original_shape))
eigen_face_1_img = Image.fromarray(eigen_face_1, 'L') 
eigen_face_1_img.show()
eigen_face_1_img.save("eigenface_1.jpg")

eigen_face_2 = np.asarray(np.int8(eigenface_matrix[:,1]).reshape(original_shape))
eigen_face_2_img = Image.fromarray(eigen_face_2, 'L') 
eigen_face_2_img.show()
eigen_face_2_img.save("eigenface_2.jpg")

eigen_face_3 = np.asarray(np.int8(eigenface_matrix[:,2]).reshape(original_shape))
eigen_face_3_img = Image.fromarray(eigen_face_3, 'L') 
eigen_face_3_img.show()
eigen_face_3_img.save("eigenface_3.jpg")

eigen_face_4 = np.asarray(np.int8(eigenface_matrix[:,3]).reshape(original_shape))
eigen_face_4_img = Image.fromarray(eigen_face_4, 'L') 
eigen_face_4_img.show()
eigen_face_4_img.save("eigenface_4.jpg")

eigen_face_5 = np.asarray(np.int8(eigenface_matrix[:,4]).reshape(original_shape))
eigen_face_5_img = Image.fromarray(eigen_face_4, 'L') 
eigen_face_5_img.show()
eigen_face_5_img.save("eigenface_5.jpg")

"""Test 1: Choose any image from the dataset of faces. Make a copy of it 
and save it as TEST_Image.pgm. Then, read it into your code, vectorize it, 
normalize it (subtract the mean), and project it to eigenface reduced space
using the eigenfaces matrix. Then, compare it to all faces in the database 
by reading in each face, doing the same steps, and taking the euclidean 
distance between each database face and the testface. Your program should 
match it with the image in the database for which the euclidean distance is smallest.

Create an image of the TEST_Image as jpg (save it to a file) AND create an 
image as jpg (and save it to a file) of the image that your program selected 
as the closest match. Call these: TEST_Image.jpg  AND PREDICTED_Image.jpg
"""

#read in test image
im = Image.open('TEST_Image.pgm').convert("L")

#vectorize test image
test_image = np.array(im).ravel()
test_matrix = np.matrix(test_image)
test_matrix_t = np.transpose(test_matrix)

#normalize test image
test_image_norm = test_matrix_t - mean_face
test_image_norm_t = np.transpose(test_image_norm)

#create eigenface matrix for test image
test_facespace = test_image_norm_t.dot(eigenface_matrix)
test_facespace_t = np.transpose(test_facespace)

#create eigenface matrix for normalized images
norm_facespace = face_matrix_norm_t.dot(eigenface_matrix)

euc_dist = []
for x in range(0,400): 
  euc_dist.append(distance.euclidean(test_facespace, norm_facespace[x]))

euc_dist_df = pd.DataFrame(euc_dist, columns = ['Euc_Dist'])

#the closest face is indexed at row 202 in dataframe
euc_dist_df.iloc[euc_dist_df['Euc_Dist'].idxmin()]

eigenface_matrix_t = np.transpose(eigenface_matrix)

#reconstruct test image in facespace
projected_face = (test_image_norm_t.dot(eigenface_matrix)).dot(eigenface_matrix_t)
#reconstruct predicted image in facespace
predicted_face = (face_matrix_norm_t[202].dot(eigenface_matrix).dot(eigenface_matrix_t))

#create .JPGs for test and predicted images
test_face = np.asarray(np.int8(projected_face).reshape(original_shape))
test_face_img = Image.fromarray(test_face, 'L') 
test_face_img.show()
test_face_img.save("TEST_Image.jpg")

predicted_face = np.asarray(np.int8(predicted_face)).reshape(original_shape)
predicted_face_img = Image.fromarray(predicted_face, 'L') 
predicted_face_img.show()
predicted_face_img.save("PREDICTED_Image.jpg")

"""Test 2: Pull an image out of the database of faces. 
Call it TEST_Image_2.pgm. BUT - in this case, you are NOT making a copy,
 but rather you are REMOVING IT from the database. Replace it with a 
 copy of some other database image - it does not matter which one. 
 The idea here is to see if your program an find a face CLOSE TO the test 
 face you removed from the dataset."""

#read in test image
im = Image.open('TEST_Image.pgm').convert("L")

#vectorize test image
test2_image = np.array(im).ravel()
test2_matrix = np.matrix(test2_image)
test2_matrix_t = np.transpose(test_matrix)

#normalize test image
test2_image_norm = test2_matrix_t - mean_face
test2_image_norm_t = np.transpose(test2_image_norm)

#create eigenface matrix for test image
test_facespace = test2_image_norm_t.dot(eigenface_matrix)
test_facespace_t = np.transpose(test_facespace)

#compute euclidean distance
euc_dist = []
for x in range(0,400): 
  euc_dist.append(distance.euclidean(test_facespace, norm_facespace[x]))

euc_dist_df = pd.DataFrame(euc_dist, columns = ['Euc_Dist'])

#the closest face is indexed at row 285 in dataframe
euc_dist_df.iloc[euc_dist_df['Euc_Dist'].idxmin()]

#create .JPGs for test and predicted images
test_face = np.asarray(np.int8(projected_face).reshape(original_shape))
test_face_img = Image.fromarray(test_face, 'L') 
test_face_img.show()
test_face_img.save("TEST_Image_2.jpg")

predicted_face = np.asarray(np.int8(predicted_face)).reshape(original_shape)
predicted_face_img = Image.fromarray(predicted_face, 'L') 
predicted_face_img.show()
predicted_face_img.save("PREDICTED_Image_2.jpg")




